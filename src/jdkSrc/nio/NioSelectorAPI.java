package jdkSrc.nio;

import java.nio.channels.SelectionKey;
import java.util.Set;

/**
 *  <一> Nio的几个主要成员
 *      
 *    <1> 选择器(Selector)
 *      选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。
 *      
 *    <2> 可选择通道(SelectableChannel)
 *      这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。
 *      SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，
 *      那一种操作是感兴趣的  
 *      
 *      【注意】
 *        FileChannel 对象不是可选择的，因为它们没有继承 SelectableChannel
 *       
 *    <3> 选择键(SelectionKey)
 *      选 择 键 封 装 了 特 定 的 通 道 与 特 定 的 选 择 器 的 注 册 关 系 。
 *
 *-------------------------------------------------------------------
 *    
 *   <二> Selector维护的集合
 *      每个Selector对象维护3个集合(Set)，每个集合的元素都是选择键(SelectionKey)。
 *      
 *     ☆    已注册的键   ☆
 *      <a> 与选择器Selector关联的已经注册的键的集合。
 *      <b> 并不是所有注册过的键都仍然有效的
 *      <c> 集合里面的key不能被直接改变,从里面删除一个key只能通过cancel这个key并且
 *          key所关联的channel已经被deregistered。
 *      <d> 调用Selector的以下方法可以得到此集合 :
 *              public abstract Set<SelectionKey> keys();
 *      
 *      
 *     ☆    已选择的键   ☆
 *      <a> 这个集合的每个成员都是相关的通道被选择器(在前一个选择操作中)判断为已经准备好的,
 *          并且包含于键的  interest 集合中的操作。
 *      <b> 这个集合是已注册的键的集合的子集。
 *      <c> 这个集合里面的key只能从set中删除,但不能添加key到里面。
 *      <d> 调用下面的方法可以得到此集合:
 *              public abstract Set<SelectionKey> selectedKeys();
 *     
 *     ☆    已取消的键   ☆
 *      <a> 已注册的键的集合的子集，这个集合包含了cancel( )方法被调用过的键（这个键已经被无效化），
 *          但它们还没有被注销。
 *      <b> 一个键被取消，就会被加到这个集合。
 *      <c> 取消可以通过：
 *          <c1> 关闭与键关联的那个通道
 *          <c2> 调用键的 cancel()方法。
 *    
 *-------------------------------------------------------------------
 *
 *  <三> Selector的select()方法
 *      调用select()方法,以下步骤会被执行:
 *      
 *      <1> 已取消的键的集合将会被检查
 *          如果它是非空的,每个已取消的键的集合中的键将从另外两个集合中移除,
 *          并且相关的通道将被注销。这个步骤结束后，已取消的键的集合将是空的。
 *          
 *      <2> 已注册的键的集合中的键的 interest 集合将被检查
 *          在这个步骤中的检查执行过后,对interest 集合的改动不会影响剩余的检查过程。
 *      
 *      <3> 一旦就绪条件被定下来,底层操作系统将会进行查询,以确定每个通道所关心的操作
 *          的真实就绪状态。依赖于特定的 select( )方法调用,如果没有通道已经准备好,
 *          线程可能会在这时阻塞,通常会有一个超时值。
 *       
 *      <4> 系统调用完成,当前每个通道的就绪状态将确定下来。对于那些还没准备好的通道将
 *          不会执行任何的操作。对于那些操作系统指示至少已经准备好 interest 集合中
 *          的一种操作的通道,将执行以下两种操作中的一种:
 *          
 *          <a> 如果通道的键还没有处于已选择的键的集合中:
 *              键的 ready 集合将被清空,然后表示操作系统发现的当前通道已经准备好
 *              的操作的比特掩码将被设置
 *          <b> 键在已选择的键的集合中:
 *              键的 ready 集合将被表示操作系统发现的当前已经准备好的操作的比特掩
 *              码更新。所有之前的已经不再是就绪状态的操作不会被清除，即它的 ready
 *              集合将是累积的
 *
 *      <5> select 操作返回的值
 *          是 ready集合在 <4>中被修改的键的数量,而不是已选择的键的集合中的通道的
 *          总数。返回值不是已准备好的通道的总数,而是从上一个 select( )调用之后
 *          进入就绪状态的通道的数量
 */


public class NioSelectorAPI {

}
