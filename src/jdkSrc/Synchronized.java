package jdkSrc;

/**
 *				******	  synchronized的实现原理		****** 
 *
 *	<一> Java对象头
 *		synchronized用的锁是存在Java对象头里的。关于对象头,有以下知识点:
 *		
 *		<☆>	对象在堆里的逻辑结构:
 *			{  对象头 , 实例变量   }
 *		<☆> 如果对象是数组类型,虚拟机使用3个字宽存储对象头(用于存储数组长度),否则使用2个字宽。
 *			32位机,1字宽  = 4字节
 *		<☆> 对象头的结构:
 *			{  
 *				Mark Word , 				//	存储对象的hashCode 或锁信息
 *				Class Metadata Address , 	//  存储到对象类型数据的指针。
 *				Array Length				//	数组的长度(如果当前对象是数组)
 *			}
 *			对象头的信息都是与对象自身定义的数据无关的额外存储成本,考虑到虚拟机的空间效率,
 *			Mark Word被设计成一个非固定的数据结构以便尽量存储多点信息,它会根据对象锁的
 *			状态复用自己的存储空间。
 *
 *		<☆> Mark Word的状态变化
 *		-----------------------------------------------------------
 *			存储内容						标志位				状态
 *		-----------------------------------------------------------
 *		对象哈希码、对象分代年龄				01					未锁定
 *		-----------------------------------------------------------
 *		指向锁记录的指针						00					轻量级锁定
 *		-----------------------------------------------------------
 *		指向重量级锁的指针					10					膨胀(重量级锁定)
 *		-----------------------------------------------------------
 *		空,不需要记录信息						11					GC标记
 *		-----------------------------------------------------------
 *		偏向线程的ID、偏向时间戳、对象分代年龄		01					可偏向
 *		-----------------------------------------------------------
 *			其实还有一个bit用于指示"是否是偏向锁",以此可以区分"未锁定"(0)和"可偏向"
 *
 *
 *	<二> 锁的升级
 *		<◆> 为了减少获得锁和释放锁的开销,引入"偏向锁"和"轻量级锁"。
 *			Java1.6中,锁一共有4种状态,级别从低到高分别是:
 *			～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
 *				无锁状态 -> 偏向锁状态 -> 轻量级锁状态 -> 重量级锁状态
 *			～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
 *			这几个状态会随着竞争情况逐渐升级,锁可以升级但不能降级。
 *
 *	  ---------------------------------------------------------------
 *	  ■ 偏向锁
 *		大多数情况,锁不但不存在多线程竞争,而且总是由同一个线程多次获得,为了降低获得锁的代价引入偏向锁。
 *		
 *		<★> 偏向锁的获取过程(假设开启了偏向锁优化)
 *			<1> 初始时对象处于 biasable & unbiased状态，并且ThreadID为0
 *			<2> 当一个线程试图锁住一个处于biasable & unbiased状态的对象时,通过一个CAS将自己
 *				的  ThreadID放置到Mark Word中 相应的位置,如果CAS操作成功进入第（3）步否则进入（4）步
 *			<3> 当进入到这一步时代表当前没有锁竞争，Object继续保持biasable状态,但是这时ThreadID字段
 *				被设置成了偏向锁所有者的ID，然后进入到第（6）步
 *			<4> 当前线程执行CAS获取偏向锁失败(这一步是偏向锁的关键),表示在该锁对象上存在竞争并且这个时候
 *				另外一个线程获得了偏向锁所有权。于是,这个想去竞争锁的线程执行   【撤销偏向锁】 的操作.
 *			<5> 当到达全局安全点(这个时候没有正在执行的字节码),它会:
 *				<a> 挂起拥有偏向锁的线程,并且在该线程的栈帧中建立锁记录
 *				<b> 把对象设置为轻量级锁状态,并且把它的Mark Word指向刚才新建的锁记录。
 *				<c> 这个被阻塞的线程被恢复执行。
 *			<6> 进入同步代码块
 *
 *		补充:	
 *			<1> 偏向锁的释放不需要做任何事情,这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态,
 *				因此即便同一个线程持续不断地加锁解锁，也是没有开销的。 
 *			<2> 偏向锁比轻量锁更容易被终结,轻量锁是在有锁竞争出现时升级为重量锁,而一般偏向锁是在有不同线程
 *				申请锁时升级为轻量锁,这也就意味着假如一个对象先被线程1加锁解锁,再被线程2加锁解锁,这过程中
 *				没有锁冲突,也一样会发生偏向锁失效,不同的是这回要先退化为无锁的状态,再加轻量锁。
 *
 *
 *	  ■ 轻量级锁
 *		引入的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。
 *
 *		<★> 轻量级锁的加锁过程
 *			<1> 在代码进入同步块的时候,如果同步对象锁状态为无锁状态(锁标志位为“01”状态,是否为偏向锁为“0”)
 *				虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前
 *				的Mark Word的拷贝，官方称之为 Displaced Mark Word。
 *			<2> 拷贝对象头中的Mark Word复制到锁记录中。
 *			<3> 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针,
 *				并将Lock record里的owner指针指向object mark word。
 *			<4> 如果更新动作成功了,那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”,
 *				即表示此对象处于轻量级锁定状态。
 *			<5> 如果这个更新操作失败了,虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧
 *				<a> 如果是就说明当前线程已经拥有了这个对象的锁,那就可以直接进入同步块继续执行。
 *				<b> 否则说明多个线程竞争锁,轻量级锁就要膨胀为重量级锁,锁标志的状态值变为“10”,
 *					Mark Word中存储的就是指向重量级锁(互斥量)的指针,后面等待锁的线程也要进入阻塞状态。
 *
 *		<★> 轻量级锁的解锁过程
 *			<1> 如果对象的Mark Word仍然指向线程的锁记录,那就用CAS操作把线程中的Displaced Mark Word
 *				对象替换对象的Mark Word。
 *			<2> 如果替换成功,整个同步过程就完成了。
 *			<3> 如果替换失败,说明有其他线程尝试过获取该锁(此时锁已膨胀),那就要在释放锁的同时，唤醒被挂起的线程。
 *
 *
 */
	
public class Synchronized {
	
}
