package TCP_IP;

/**
 *   ◆ 内核在处理接收到的TCP报文时使用了4个队列容器,分别为 
 *              receive、out_of_order、prequeue、backlog队列
 *      
 *        ■ receive队列
 *          允许用户进程直接读取的，它是将已经接收到的TCP报文，去除了TCP头部、排好序放入的、
 *          用户进程可以直接按序读取的队列。
 *        ■ out_of_order队列
 *          所有乱序的报文都会暂时放在这个队列。
 *        ■ backlog队列
 *          进程正在拷贝数据时，网卡收到的报文会进这个队列。
 * 
 * 
 * 
 *  <一> TCP接收消息的场景1
 *  
 *    <1> 当网卡接收到报文并判断为TCP协议后，将会调用到内核的tcp_v4_rcv方法。
 *        此时，这个TCP连接上需要接收的下一个报文序号恰好就是S1，而这一步里，网卡上收到了
 *        S1-S2的报文，所以，tcp_v4_rcv方法会把这个报文直接插入到receive队列中。
 *        由于socket不在进程上下文中（也就是没有进程在读socket），由于我们需要S1序号的报文，
 *        而恰好收到了S1-S2报文，因此，它进入了receive队列。
 *        
 *    <2> 在第1步结束后，这时我们需要收到的是S2序号,但到来的报文却是S3-S4。于是进入
 *        out_of_order队列。
 *
 *    <3> 仍然没有进程来读取socket,但又过来了我们期望的S2-S3报文，它会像第1步一样，
 *        直接进入receive队列。不同的时，由于此时out_of_order队列不像第1步是空的，
 *        所以，引发了接来的第4步.
 *
 *    <4> 每次向receive队列插入报文时都会检查out_of_order队列。由于收到S2-S3报文后，
 *        期待的序号成为了S3，这样，out_of_order队列里的唯一报文S3-S4报文将会移出本队列
 *        而插入到receive队列中（这件事由tcp_ofo_queue方法完成）。
 *
 *    <5> 终于有用户进程开始读取socket了。需要先在进程里分配一块内存，接着调用read或者recv
 *        等方法，把内存的首地址和内存长度传入，再把建立好连接的socket也传入。进程调用了recv方法。
 *    
 *    <6> 执行到tcp_recvmsg方法里面,会先锁住socket。因此socket是可以被多进程同时使用的，
 *        内核中断也会操作它，锁住后，再有用户进程进来时拿不到锁就要休眠在这了。
 *        
 *    <7> 第1-4步已经为receive队列里准备好了3个报文。最上面的报文是S1-S2，将它拷贝到用户态内存中。
 *        如果进程调用了recv方法没有指定MSG_PEEK标志位，就把S1-S2报文从receive队列的头部移除，
 *        从内核态释放掉。反之，MSG_PEEK标志位会导致receive队列不会删除报文。所以，MSG_PEEK
 *        主要用于多进程读取同一套接字的情形。
 *  
 *    <8> 拷贝S2-S3, S3-S4报文到用户态内存中。当然，执行拷贝前都会检查用户态内存的剩余空间是否足以
 *        放下当前这个报文，不足以时会直接返回已经拷贝的字节数。
 *
 *    <9> receive队列为空了，此时会先来检查SO_RCVLOWAT这个阀值。如果已经拷贝的字节数到现在还小于
 *        它，那么可能导致进程会休眠，等待拷贝更多的数据。socket套接字使用的默认的SO_RCVLOWAT，
 *        也就是1，这表明，只要读取到报文了，就认为可以返回了。
 *        做完这个检查了，再检查backlog队列。此时若backlog队列有数据，就顺带处理下。
 *
 *   <10> 释放锁，返回用户态。
 *   <11> 用户进程代码开始执行，此时recv等方法返回的就是S4-S1，即从内核拷贝的字节数.
 *   
 *--------------------------------------------------------------------------   
 *   
 *   <二> TCP接收消息的场景2
 *   
 *     用户进程调用recv方法时，没有任何接收并缓存到内核的报文，而socket是阻塞的，所以进程睡眠了。
 *     然后网卡中收到了TCP连接上的报文，此时prequeue队列开始产生作用。设置tcp_low_latency为默认的0，
 *     套接字socket的SO_RCVLOWAT是默认的1，仍然是阻塞socket。
 *   
 *   <1> 用户进程分配了一块len大小的内存，将其传入recv这样的函数，同时socket参数皆为默认，
 *       即阻塞的、SO_RCVLOWAT为1。调用接收方法，其中flags参数为0。
 *   
 *   <2> 内核最终调用到tcp_recvmsg方法来处理。
 *   
 *   <3> 锁住socket。
 *   
 *   <4> 由于此时receive、prequeue、backlog队列都是空的，即没有拷贝1个字节的消息到用户内存中，
 *       而我们的最低要求是拷贝至少SO_RCVLOWAT为1长度的消息。此时，开始进入阻塞式套接字的等待流程。
 *       最长等待时间为SO_RCVTIMEO指定的时间。
 *   
 *       在睡眠前会调用release_sock，这个方法会释放socket锁，使得下面的第5步中，新到的报文不再
 *       只能进入backlog队列。
 *       
 *   <5> 这个套接字上期望接收的序号也是S1，此时网卡恰好收到了S1-S2的报文，在tcp_v4_rcv方法中，
 *       通过调用tcp_prequeue方法把报文插入到prequeue队列中。
 *   
 *   <6> 插入prequeue队列后，此时会接着调用wake_up_interruptible方法，唤醒在socket上睡眠的进程。
 *   
 *   <7> 用户进程被唤醒后，重新调用lock_sock接管了这个socket，此后再进来的报文都只能进入backlog队列了。
 *   
 *   <8> 进程醒来后，先去检查receive队列，当然仍然是空的；再去检查prequeue队列，发现有一个报文S1-S2，
 *       正好是socket连接待拷贝的起始序号S1，于是，从prequeue队列中取出这个报文并把内容复制到用户内存中，
 *       再释放内核中的这个报文。
 *   
 *   <9> 目前已经拷贝了S2-S1个字节到用户态，检查这个长度是否超过了最低阀值（即len和SO_RCVLOWAT的最小值）。
 *   
 *  <10> 由于SO_RCVLOWAT使用了默认的1，所以准备返回用户。此时会顺带再看看backlog队列中有没有数据，
 *       若有，则检查这个无序的队列中是否有可以直接拷贝给用户的报文。当然，此时是没有的。所以准备返回，
 *       释放socket锁。 
 *   
 *  <11> 返回用户已经拷贝的字节数。
 *  
 *  
 *--------------------------------------------------------------------------   
 *  
 *  
 *  <三> TCP接收消息的场景3
 *  
 *      我们把系统参数tcp_low_latency设为1，socket上设置了SO_RCVLOWAT属性的值。
 *      服务器先是收到了S1-S2这个报文，但S2-S1的长度是小于SO_RCVLOWAT的，用户进程调用
 *      recv方法读套接字时，虽然读到了一些，但没有达到最小阀值，所以进程睡眠了，与此同时，在
 *      睡眠前收到的乱序的S3-S4包直接进入backlog队列。此时先到达了S2-S3包，由于没有使用
 *      prequeue队列，而它起始序号正是下一个待拷贝的值，所以直接拷贝到用户内存中，总共拷贝字节数
 *      已满足SO_RCVLOWAT的要求！最后在返回用户前把backlog队列中S3-S4报文也拷贝给用户了。
 *  
 *    <1> 内核收到报文S1-S2，S1正是这个socket连接上待接收的序号，因此，直接将它插入有序的receive队列中。
 *    
 *    <2> 用户进程将sysctl中的tcp_low_latency设置为1。这意味着，这台服务器希望TCP进程能够更及时的接收
 *        到TCP消息。用户调用了recv方法接收socket上的消息，这个socket上设置了SO_RCVLOWAT属性为某个值n，
 *        这个n是大于S2-S1，也就是第1步收到的报文大小。这里，仍然是阻塞socket，用户依然是分配了足够大的len长度
 *        内存以接收TCP消息。
 *    
 *    <3> 通过tcp_recvmsg方法来完成接收工作。先锁住socket，避免并发进程读取同一socket的同时，也在告诉内核
 *        网络软中断处理到这一socket时要有不同行为,如第6步。
 *        
 *    <4> 准备处理内核各个接收队列中的报文。
 *    
 *    <5> receive队列中的有序报文可直接拷贝，在检查到S2-S1是小于len之后，将报文内容拷贝到用户态内存中。
 *    
 *    <6> 在第5步进行的同时，socket是被锁住的，这时内核又收到了一个S3-S4报文，因此报文直接进入backlog队列。
 *        注意，这个报文不是有序的，因为此时连接上期待接收序号为S2。
 *        
 *    <7> 在第5步，拷贝了S2-S1个字节到用户内存，它是小于SO_RCVLOWAT的，因此，由于socket是阻塞型套接字
 *        （超时时间在本文中忽略），进程将不得不转入睡眠。转入睡眠之前，还会干一件事，就是处理backlog队列里的报文,
 *        遍历到S3-S4报文，但因为它是失序的，所以从backlog队列中移入out_of_order队列中.
 *        
 *    <8> 进程休眠，直到超时或者receive队列不为空。
 *    
 *    <9> 内核接收到了S2-S3报文。注意，这里由于打开了tcp_low_latency标志位，这个报文是不会进入prequeue
 *        队列以待进程上下文处理的。
 *  
 *   <10> 此时，由于S2是连接上正要接收的序号，同时，有一个用户进程正在休眠等待接收数据中，且它要等待的数据起始序号
 *        正是S2，于是，这种种条件下，使得这一步同时也是网络软中断执行上下文中，把S2-S3报文直接拷贝进用户内存。
 *  
 *   <11> 每处理完1个有序报文（无论是拷贝到receive队列还是直接复制到用户内存）后都会检查out_of_order队列，
 *        看看是否有报文可以处理。那么，S3-S4报文恰好是待处理的，于是拷贝进用户内存。然后唤醒用户进程。
 *  
 *   <12> 用户进程被唤醒了，当然唤醒后会先来拿到socket锁。以下执行又在进程上下文中了。
 *   
 *   <13> 此时会检查已拷贝的字节数是否大于SO_RCVLOWAT，以及backlog队列是否为空。两者皆满足，准备返回。
 *   
 *   <14> 释放socket锁，退出tcp_recvmsg方法。
 *   
 *   <15> 返回用户已经复制的字节数S4-S1。
 *  
 *   
 */

public class RecvMsg {

}
