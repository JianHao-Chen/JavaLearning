package TCP_IP;

/**
 *  <一> 【TCP的首部】
 *      
 *      ----------------------------------------
 *       16位源端口号                                                 16位目的端口号
 *                  32位序号
 *                  32位确认号
 *       4位首部长度| 保留(6位) | 标志位 | 16位窗口大小
 *       16位检验和                                                     16位紧急指针
 *                      选项
 *                      数据
 *      ----------------------------------------
 *      <1> 序号:     用于标识从TCP发端向TCP收端发送的数据字节流,它表示本报文段中的第一个字节
 *                   在数据流中的序号。
 *      <2> 确认号:    包含发送确认的一端所期望收到的下一个序号。确认序号应当是上次已成功收到数据字节序号加1。
 *    
 *    
 *    
 *    
 *  <二> 【TCP的三次握手 】
 *  
 *    -----------------------------------------------------------------------------
 *                                                                   LISTEN(被动打开)
 *                                                   
 *   主动打开 SYN_SENT: (SYN=1 , seq = client_ISN )     ---->                  
 *    
 *                  <--(SYN=1,seq = server_ISN, ack = client_ISN+1)  SYN_RCVD
 *    
 *    ESTABLISHED   (SYN=0 , ack = server_ISN+1)    -->
 *    
 *                                                                   ESTABLISHED
 *                                                                   
 *    -----------------------------------------------------------------------------
 *    
 *    ！！   client端发送数据的第一字节序号为 client_ISN+1 , 因为SYN标志是要消耗一个序号的。
 *      
 *    三次握手的原因:
 *          ★   为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
 *          
 *    “已失效的连接请求报文段”的产生在这样一种情况下:
 *          client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到
 *          连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的
 *          连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报
 *          文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于
 *          现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。
 *          但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源
 *          就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向
 *          server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”
 *    
 *    
 *    <三> 【TCP建立连接的实现 】
 *       
 *      ◆       listen()函数
 *              #include<sys/socket.h>
 *              int listen(int sockfd, int backlog);
 *              
 *          listen函数仅由TCP服务器调用，它做两件事情:
 *          <1> listen函数把一个未连接的套接口转换成一个被动套接口，指示内核应接受指向该套接口的连接请求。
 *              (当socket函数创建一个套接口时，它被假设为一个主动套装口),调用listen导致套接口从CLOSED
 *              状态转换到LISTEN状态。
 *          <2> 本函数的第二个参数规定了内核应该为相应套接口排队的最大连接个数。
 *          
 *          内核为任何一个给定的监听套接口维护两个队列:
 *          <1> 未完成连接队列
 *              客户端的SYN包到达了服务器后，内核会把这一信息放到SYN队列（即未完成握手队列）
 *          <2> 已完成连接队列
 *              每个已完成TCP三路握手的客户对应其中一项。这些套接口处于ESTABLISHED状态。
 *       
 *          ◎  backlog
 *              是已连接但未进行accept处理的SOCKET队列大小,即已完成连接队列的大小。
 *       
 *       ◆       accept()函数
 *              服务器调用accept()函数,会直接从已完成连接队列取出连接套接字。
 *       
 */

public class BuildConnection {

}
