package TCP_IP;

/**
 *  <一> MSS与TCP的分片
 *  
 *   <1> 最大传输单元MTU
 *      无论何种类型的数据链路层，都会对网络分组的长度有一个限制。例如以太网限制为1500字节，
 *     802.3限制为1492字节。当内核的IP网络层试图发送报文时，若一个报文的长度大于MTU限制，
 *     就会被分成若干个小于MTU的报文，每个报文都会有独立的IP头部。
 *
 *     IP包总长度的是一个16位（2字节）的字段,这意味一个IP包最大可以是65535字节。
 *     
 *      若TCP层在以太网中试图发送一个大于1500字节的消息，调用IP网络层方法发送消息时，
 *     IP层会自动的获取所在局域网的MTU值，并按照所在网络的MTU大小来分片。IP层同时
 *     希望这个分片对于传输层来说是透明的，接收方的IP层会根据收到的多个IP包头部，将
 *     发送方IP层分片出的IP包重组为一个消息。
 *
 *      这种IP层的分片效率是很差的，因为必须所有分片都到达才能重组成一个包，其中任何一个分片丢失了，
 *     都必须重发所有分片。所以，TCP层会试图避免IP层执行数据报分片。
 *     
 *   <2> 最大报文段长度MSS  
 *        为了避免IP层的分片，TCP协议定义了一个新的概念:最大报文段长度MSS。它定义了一个TCP连接上，
 *      一个主机期望对端主机发送单个报文的最大长度。TCP 3次握手建立连接时，连接双方都要互相告知自己
 *      期望接收到的MSS大小。
 *      
 *        这个MSS是预估的，TCP连接上的两台主机若处于不同的网络中，那么，连接上可能有许多中间网络，
 *      这些网络分别具有不同的数据链路层，这样，TCP连接上有许多个MTU。特别是，若中间途径的MTU
 *      小于两台主机所在的网络MTU时，选定的MSS仍然太大了，会导致中间路由器出现IP层的分片。
 *      
 *      怎样避免中间网络可能出现的分片呢？
 *        通过IP头部的DF标志位，这个标志位是告诉IP报文所途经的所有IP层代码:不要对这个报文分片。
 *      如果一个IP报文太大必须要分片，则直接返回一个ICMP错误，说明必须要分片了，且待分片路由器
 *      网络接受的MTU值。这样，连接上的发送方主机就可以重新确定MSS。
 *      
 *      
 *  <二> TCP是如何保证可靠传输的
 *        TCP把自己要发送的数据流里的每一个字节都看成一个序号，可靠性是要求连接对端在接收到数据后，
 *      要发送ACK确认，告诉它已经接收到了多少字节的数据。      
 *  
 *  
 *  <三> TCP发送消息的流程
 *      
 *      <1> 应用程序试图调用send方法来发送一段较长的数据
 *      <2> 内核主要通过tcp_sendmsg方法来完成。
 *      <3> 把用户需要发送的用户态内存中的数据，拷贝到内核态内存中。
 *          <a> 拷贝到内核态内存,是为了不依赖于用户态内存，也使得进程可以快速释放发送数据占用的
 *              用户态内存。
 *          <b> 这个拷贝操作并不是简单的复制，而是把待发送数据，按照MSS来划分成多个尽量达到MSS
 *              大小的分片报文段，复制到内核中的sk_buff结构来存放，同时把这些分片组成队列，放到
 *              这个TCP连接对应的tcp_write_queue发送队列中。
 *              
 *      <4> 内核中为这个TCP连接分配的内核缓存是有限的.当没有多余的内核态缓存来复制用户态的待发送数
 *          据时，就需要调用一个方法sk_stream_wait_memory来等待滑动窗口移动，释放出一些缓存
 *          出来（收到ACK后，不需要再缓存原来已经发送出的报文，因为既然已经确认对方收到，就不需要定
 *          时重发，自然就释放缓存了）。
 *          
 *          “
 *              if ((err = sk_stream_wait_memory(sk, &timeo)) != 0)
 *                  goto do_error; 
 *                                                                 ”
 *          
 *          sk_stream_wait_memory方法接受一个参数timeo，就是等待超时的时间 ,这个时间是
 *          tcp_sendmsg方法刚开始就拿到的。
 *          
 *          当这个套接字是阻塞套接字时，timeo就是SO_SNDTIMEO选项指定的发送超时时间。
 *          当这个套接字是非阻塞套接字， timeo变量就会是0。sk_stream_wait_memory
 *          会直接返回，并将 errno错误码置为EAGAIN。
 *      
 *      
 *        ◇ 补充
 *          SO_RCVTIMEO和SO_SNDTIMEO ，它们分别用来设置socket接收数据超时时间和发送数据超时时间。
 *          这两个选项仅对与数据收发相关的系统调用有效，这些系统调用包括:
 *              send, sendmsg, recv, recvmsg, accept, connect
 *              
 *          这两个选项设置后，若超时， 返回-1，并设置errno为EAGAIN或EWOULDBLOCK.
 *          其中connect超时的话，也是返回-1, 但errno设置为EINPROGRESS
  
 *      <5> 调用tcp_push等方法,它最终会调用IP层的方法来发送tcp_write_queue队列中的报文。
 *          【注意】:
 *              IP层返回时，并不一定是把报文发送了出去。
 *      
 *      ■ 总结:
 *          无论是使用阻塞还是非阻塞套接字，发送方法成功返回时（无论全部成功或者部分成功），既不代表
 *        TCP连接的另一端主机接收到了消息，也不代表本机把消息发送到了网络上，只是说明，内核将会试图
 *        保证把消息送达对方。
 *   
 *   
 *   
 *   
 *   
 *  <四> 主要的流程
 *      
 *          ---------------------------------------------------
 *          【tcp_sendmsg】
 *          
 *              [sk_stream_wait_memory]若内核缓存不足则等待直到超时
 *                              ↓
 *              [tcp_sendmsg] 拷贝用户态数据到内核态发送缓存中
 *                              ↓
 *          ---------------------------------------------------                
 *          【tcp_push】(本质是做一些检查和)
 *                              ↓
 *              [tcp_cwnd_test]检查飞行中的报文个数是否超过拥塞窗口
 *                              ↓
 *              [tcp_snd_wnd_test]检查待发的序号是否超出了发送窗口
 *                              ↓                
 *              [tcp_nagle_test]根据nagle算法检查是否应该发送
 *                              ↓
 *        [tcp_window_allows]检查待发送的报文长度是否超出拥塞窗口和发送窗口的最小值
 *                              ↓
 *               [tcp_transmit_skb]调用IP层的方法发送报文                               
 *           ---------------------------------------------------   
 *                              
 *    <1> 滑动窗口
 *      TCP连接上的双方都会通知对方自己的接收窗口大小。而对方的接收窗口大小就是自己的发送窗口大小。
 *      发送窗口是一个时刻变化的值，随着ACK的到达会变大，随着发出新的数据包会变小。tcp_push在
 *      发送数据时，最终会使用tcp_snd_wnd_test方法来判断当前待发送的数据，其序号是否超出了
 *      发送滑动窗口的大小。
 *    
 *    <2> 慢启动和拥塞窗口
 *      由于两台主机间的网络可能很复杂，通过广域网时，中间的路由器转发能力可能是瓶颈。也就是说，
 *      如果一方简单的按照另一方主机三次握手时通告的滑动窗口大小来发送数据的话，可能会使得网络上
 *      的转发路由器性能雪上加霜，最终丢失更多的分组。
 *      
 *      这时，各个操作系统内核都会对TCP的发送阶段加入慢启动和拥塞避免算法。
 *      【慢启动算法】
 *          说白了，就是对方通告的窗口大小表示对方接收TCP分组的能力，不表示中间网络能够处理分组的能力。
 *          所以，发送方请悠着点发，确保网络非常通畅了后，再按照对方通告窗口来敞开了发。
 *      【拥塞窗口】
 *          就是下面的cwnd，它用来帮助慢启动的实现。连接刚建立时，拥塞窗口的大小远小于发送窗口，
 *          它实际上是一个MSS。每收到一个ACK，拥塞窗口扩大一个MSS大小，当然，拥塞窗口最大只能
 *          到对方通告的接收窗口大小。
 *          
 *          所以，在tcp_push发送消息时，还会检查拥塞窗口，飞行中的报文数要小于拥塞窗口个数，
 *          而发送数据的长度也要小于拥塞窗口的长度。
 *          
 *     <3> 是否符合NAGLE算法
 *      Nagle算法的初衷是: 
 *          应用进程调用发送方法时，可能每次只发送小块数据，造成这台机器发送了许多小的TCP报文。
 *          对于整个网络的执行效率来说，小的TCP报文会增加网络拥塞的可能，因此，如果有可能，应该
 *          将相临的TCP报文合并成一个较大的TCP报文（当然还是小于MSS的）发送。
 *          
 *          Nagle算法要求一个TCP连接上最多只能有一个发送出去还没被确认的小分组，在该分组的确认
 *          到达之前不能发送其他的小分组。
 *          
 *          
 *     ■  调用了IP层的方法返回后，也未必就保证此时数据一定发送到网络中去了
 *     
 */

public class SendMsg {

}
